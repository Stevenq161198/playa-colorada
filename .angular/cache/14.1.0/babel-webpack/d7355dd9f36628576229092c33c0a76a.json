{"ast":null,"code":"import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env'; // Map() is not used in order to decrease the bundle\n\nlet marksMap = {};\nlet marksObserver = {};\n/**\n * Get the current time based on User Timing API or Date\n *\n * @returns number\n *\n */\n\nconst getTimeNow = () => isUserTimingAPISupported ? performance.now() : Date.now();\n/**\n * Clear marks and measure of performance event\n *\n * @param markName - Performance marker to be checked\n *\n * @returns void\n *\n */\n\n\nconst clear = markName => {\n  marksMap[markName] = undefined; // Removes PerformanceObserver references from memory\n\n  if (!!marksObserver[markName]) {\n    marksObserver[markName] = undefined;\n  }\n\n  if (!isUserTimingAPISupported) {\n    return;\n  } // Some versions of NodeJS doesn't support this method\n\n\n  if (!isNodeJSEnv) {\n    performance.clearMeasures(markName);\n  }\n\n  performance.clearMarks(markName);\n};\n/**\n * Start performance measure of event\n *\n * @param markName - Performance marker to be started\n *\n * @returns number\n *\n */\n\n\nconst start = markName => {\n  if (isUserTimingAPISupported) {\n    if (isNodeJSEnv && isPerformanceObservableSupported) {\n      // eslint-disable-next-line compat/compat\n      const obs = new PerformanceObserver(list => {\n        marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n        obs.disconnect();\n      });\n      obs.observe({\n        entryTypes: ['measure']\n      });\n    }\n\n    performance.mark(markName);\n  }\n\n  marksMap[markName] = getTimeNow();\n};\n/**\n * Finishes performance measure of event and\n * clear marks and measure if applicable\n *\n * @param markName - Performance marker to be checked\n * @param markNameToCompare - Optional mark to compare to\n *\n * @returns PerfMarksPerformanceEntry\n *\n */\n\n\nconst end = (markName, markNameToCompare) => {\n  try {\n    const startTime = marksMap[markName];\n\n    if (!isUserTimingAPISupported) {\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    } // If there's no User Timing mark to be compared with,\n    // the package will create one to be used for better comparison\n\n\n    if (!markNameToCompare) {\n      performance.mark(`${markName}-end`);\n    }\n\n    performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n\n    if (isNodeJSEnv) {\n      if (!!marksObserver[markName]) {\n        return marksObserver[markName];\n      }\n\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n\n    const entry = performance.getEntriesByName(markName).pop();\n    return entry || {};\n  } catch (e) {\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if something in event loop crashed\n    // in an unexpected place earlier.\n    // Don't pile on with more errors.\n    return {};\n  } finally {\n    // Clear marks immediately to avoid growing buffer.\n    clear(markName); // Clear marks used for comparison in case of it's value was passed\n    // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n\n    clear(markNameToCompare || `${markName}-end`);\n  }\n};\n/**\n * Clear all marks and measures of performance event\n *\n * @returns void\n *\n */\n\n\nconst clearAll = () => {\n  marksMap = {};\n  marksObserver = {};\n\n  if (!isUserTimingAPISupported) {\n    return;\n  } // Some versions of NodeJS doesn't support this method\n\n\n  if (!isNodeJSEnv) {\n    performance.clearMeasures();\n  }\n\n  performance.clearMarks();\n};\n\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };","map":{"version":3,"names":["isUserTimingAPISupported","isPerformanceObservableSupported","isNodeJSEnv","marksMap","marksObserver","getTimeNow","performance","now","Date","clear","markName","undefined","clearMeasures","clearMarks","start","obs","PerformanceObserver","list","getEntries","find","f","name","disconnect","observe","entryTypes","mark","end","markNameToCompare","startTime","duration","entryType","measure","entry","getEntriesByName","pop","e","clearAll"],"sources":["/Users/stevenquesada/Documents/playa-colorada/node_modules/perf-marks/dist/es2020/marks.js"],"sourcesContent":["import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env';\n// Map() is not used in order to decrease the bundle\nlet marksMap = {};\nlet marksObserver = {};\n/**\n * Get the current time based on User Timing API or Date\n *\n * @returns number\n *\n */\nconst getTimeNow = () => (isUserTimingAPISupported ? performance.now() : Date.now());\n/**\n * Clear marks and measure of performance event\n *\n * @param markName - Performance marker to be checked\n *\n * @returns void\n *\n */\nconst clear = (markName) => {\n    marksMap[markName] = undefined;\n    // Removes PerformanceObserver references from memory\n    if (!!marksObserver[markName]) {\n        marksObserver[markName] = undefined;\n    }\n    if (!isUserTimingAPISupported) {\n        return;\n    }\n    // Some versions of NodeJS doesn't support this method\n    if (!isNodeJSEnv) {\n        performance.clearMeasures(markName);\n    }\n    performance.clearMarks(markName);\n};\n/**\n * Start performance measure of event\n *\n * @param markName - Performance marker to be started\n *\n * @returns number\n *\n */\nconst start = (markName) => {\n    if (isUserTimingAPISupported) {\n        if (isNodeJSEnv && isPerformanceObservableSupported) {\n            // eslint-disable-next-line compat/compat\n            const obs = new PerformanceObserver(list => {\n                marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n                obs.disconnect();\n            });\n            obs.observe({ entryTypes: ['measure'] });\n        }\n        performance.mark(markName);\n    }\n    marksMap[markName] = getTimeNow();\n};\n/**\n * Finishes performance measure of event and\n * clear marks and measure if applicable\n *\n * @param markName - Performance marker to be checked\n * @param markNameToCompare - Optional mark to compare to\n *\n * @returns PerfMarksPerformanceEntry\n *\n */\nconst end = (markName, markNameToCompare) => {\n    try {\n        const startTime = marksMap[markName];\n        if (!isUserTimingAPISupported) {\n            return startTime\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\n                : {};\n        }\n        // If there's no User Timing mark to be compared with,\n        // the package will create one to be used for better comparison\n        if (!markNameToCompare) {\n            performance.mark(`${markName}-end`);\n        }\n        performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n        if (isNodeJSEnv) {\n            if (!!marksObserver[markName]) {\n                return marksObserver[markName];\n            }\n            return startTime\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\n                : {};\n        }\n        const entry = performance.getEntriesByName(markName).pop();\n        return entry || {};\n    }\n    catch (e) {\n        // If previous mark was missing for some reason, this will throw.\n        // This could only happen if something in event loop crashed\n        // in an unexpected place earlier.\n        // Don't pile on with more errors.\n        return {};\n    }\n    finally {\n        // Clear marks immediately to avoid growing buffer.\n        clear(markName);\n        // Clear marks used for comparison in case of it's value was passed\n        // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n        clear(markNameToCompare || `${markName}-end`);\n    }\n};\n/**\n * Clear all marks and measures of performance event\n *\n * @returns void\n *\n */\nconst clearAll = () => {\n    marksMap = {};\n    marksObserver = {};\n    if (!isUserTimingAPISupported) {\n        return;\n    }\n    // Some versions of NodeJS doesn't support this method\n    if (!isNodeJSEnv) {\n        performance.clearMeasures();\n    }\n    performance.clearMarks();\n};\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}