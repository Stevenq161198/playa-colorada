{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"fast-copy\"] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf$1 = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\n  var WEAK_MAP = typeof WeakMap === 'function';\n  /**\n   * @function createCache\n   *\n   * @description\n   * get a new cache object to prevent circular references\n   *\n   * @returns the new cache object\n   */\n\n  var createCache = function () {\n    if (WEAK_MAP) {\n      return function () {\n        return new WeakMap();\n      };\n    }\n\n    var Cache =\n    /** @class */\n    function () {\n      function Cache() {\n        this._keys = [];\n        this._values = [];\n      }\n\n      Cache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n      };\n\n      Cache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n      };\n\n      Cache.prototype.set = function (key, value) {\n        this._keys.push(key);\n\n        this._values.push(value);\n      };\n\n      return Cache;\n    }();\n\n    return function () {\n      return new Cache();\n    };\n  }();\n  /**\n   * @function getCleanClone\n   *\n   * @description\n   * get an empty version of the object with the same prototype it has\n   *\n   * @param object the object to build a clean clone from\n   * @param realm the realm the object resides in\n   * @returns the empty cloned object\n   */\n\n\n  var getCleanClone = function (object, realm) {\n    var prototype = object.__proto__ || getPrototypeOf$1(object);\n\n    if (!prototype) {\n      return create(null);\n    }\n\n    var Constructor = prototype.constructor;\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\n   * @function getObjectCloneLoose\n   *\n   * @description\n   * get a copy of the object based on loose rules, meaning all enumerable keys\n   * and symbols are copied, but property descriptors are not considered\n   *\n   * @param object the object to clone\n   * @param realm the realm the object resides in\n   * @param handleCopy the function that handles copying the object\n   * @returns the copied object\n   */\n\n\n  var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n\n      for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\n   * @function getObjectCloneStrict\n   *\n   * @description\n   * get a copy of the object based on strict rules, meaning all keys and symbols\n   * are copied based on the original property descriptors\n   *\n   * @param object the object to clone\n   * @param realm the realm the object resides in\n   * @param handleCopy the function that handles copying the object\n   * @returns the copied object\n   */\n\n\n  var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n\n    for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\n   * @function getRegExpFlags\n   *\n   * @description\n   * get the flags to apply to the copied regexp\n   *\n   * @param regExp the regexp to get the flags of\n   * @returns the flags for the regexp\n   */\n\n\n  var getRegExpFlags = function (regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  var GLOBAL_THIS = function () {\n    if (typeof globalThis !== 'undefined') {\n      return globalThis;\n    }\n\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n\n    return this;\n  }();\n  /**\n   * @function copy\n   *\n   * @description\n   * copy an value deeply as much as possible\n   *\n   * If `strict` is applied, then all properties (including non-enumerable ones)\n   * are copied with their original property descriptors on both objects and arrays.\n   *\n   * The value is compared to the global constructors in the `realm` provided,\n   * and the native constructor is always used to ensure that extensions of native\n   * objects (allows in ES2015+) are maintained.\n   *\n   * @param value the value to copy\n   * @param [options] the options for copying with\n   * @param [options.isStrict] should the copy be strict\n   * @param [options.realm] the realm (this) value the value is copied from\n   * @returns the copied value\n   */\n\n\n  function copy(value, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\n     * @function handleCopy\n     *\n     * @description\n     * copy the value recursively based on its type\n     *\n     * @param value the value to copy\n     * @returns the copied value\n     */\n\n    var handleCopy = function (value, cache) {\n      if (!value || typeof value !== 'object') {\n        return value;\n      }\n\n      if (cache.has(value)) {\n        return cache.get(value);\n      }\n\n      var prototype = value.__proto__ || getPrototypeOf(value);\n      var Constructor = prototype && prototype.constructor; // plain objects\n\n      if (!Constructor || Constructor === realm.Object) {\n        return getObjectClone(value, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(value)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(value, realm, handleCopy, cache);\n        }\n\n        clone = new Constructor();\n        cache.set(value, clone);\n\n        for (var index = 0, length_1 = value.length; index < length_1; ++index) {\n          clone[index] = handleCopy(value[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (value instanceof realm.Date) {\n        return new Constructor(value.getTime());\n      } // regexps\n\n\n      if (value instanceof realm.RegExp) {\n        clone = new Constructor(value.source, value.flags || getRegExpFlags(value));\n        clone.lastIndex = value.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && value instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && value instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && value instanceof realm.Blob) {\n        return value.slice(0, value.size, value.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);\n        cache.set(value, clone);\n        value.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(value)) {\n          clone = new Constructor(value.buffer.slice(0));\n          cache.set(value, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (value instanceof realm.ArrayBuffer) {\n          clone = value.slice(0);\n          cache.set(value, clone);\n          return clone;\n        }\n      } // if the value cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof value.then === 'function' || // errors\n      value instanceof Error || // weakmaps\n      realm.WeakMap && value instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && value instanceof realm.WeakSet) {\n        return value;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(value, realm, handleCopy, cache);\n    };\n\n    return handleCopy(value, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported value. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\n   * @function strictCopy\n   *\n   * @description\n   * copy the value with `strict` option pre-applied\n   *\n   * @param value the value to copy\n   * @param [options] the options for copying with\n   * @param [options.realm] the realm (this) value the value is copied from\n   * @returns the copied value\n   */\n\n  copy.strict = function strictCopy(value, options) {\n    return copy(value, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","toStringFunction","Function","prototype","toString","create","Object","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf$1","getPrototypeOf","_a","hasOwnProperty","propertyIsEnumerable","SYMBOL_PROPERTIES","WEAK_MAP","WeakMap","createCache","Cache","_keys","_values","has","key","indexOf","get","set","value","push","getCleanClone","object","realm","__proto__","Constructor","constructor","call","getObjectCloneLoose","handleCopy","cache","clone","symbols","index","length_1","length","symbol","getObjectCloneStrict","properties","concat","length_2","property","descriptor","error","getRegExpFlags","regExp","flags","ignoreCase","multiline","unicode","sticky","isArray","Array","GLOBAL_THIS","window","console","copy","options","isStrict","getObjectClone","Date","getTime","RegExp","source","lastIndex","Map","forEach","Set","add","Blob","slice","size","type","Buffer","isBuffer","allocUnsafe","ArrayBuffer","isView","buffer","then","Error","WeakSet","default","strict","strictCopy"],"sources":["/Users/stevenquesada/Documents/playa-colorada/node_modules/fast-copy/dist/fast-copy.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"fast-copy\"] = factory());\n})(this, (function () { 'use strict';\n\n    var toStringFunction = Function.prototype.toString;\n    var create = Object.create, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf$1 = Object.getPrototypeOf;\n    var _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;\n    var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\n    var WEAK_MAP = typeof WeakMap === 'function';\n    /**\n     * @function createCache\n     *\n     * @description\n     * get a new cache object to prevent circular references\n     *\n     * @returns the new cache object\n     */\n    var createCache = (function () {\n        if (WEAK_MAP) {\n            return function () { return new WeakMap(); };\n        }\n        var Cache = /** @class */ (function () {\n            function Cache() {\n                this._keys = [];\n                this._values = [];\n            }\n            Cache.prototype.has = function (key) {\n                return !!~this._keys.indexOf(key);\n            };\n            Cache.prototype.get = function (key) {\n                return this._values[this._keys.indexOf(key)];\n            };\n            Cache.prototype.set = function (key, value) {\n                this._keys.push(key);\n                this._values.push(value);\n            };\n            return Cache;\n        }());\n        return function () { return new Cache(); };\n    })();\n    /**\n     * @function getCleanClone\n     *\n     * @description\n     * get an empty version of the object with the same prototype it has\n     *\n     * @param object the object to build a clean clone from\n     * @param realm the realm the object resides in\n     * @returns the empty cloned object\n     */\n    var getCleanClone = function (object, realm) {\n        var prototype = object.__proto__ || getPrototypeOf$1(object);\n        if (!prototype) {\n            return create(null);\n        }\n        var Constructor = prototype.constructor;\n        if (Constructor === realm.Object) {\n            return prototype === realm.Object.prototype ? {} : create(prototype);\n        }\n        if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n            try {\n                return new Constructor();\n            }\n            catch (_a) { }\n        }\n        return create(prototype);\n    };\n    /**\n     * @function getObjectCloneLoose\n     *\n     * @description\n     * get a copy of the object based on loose rules, meaning all enumerable keys\n     * and symbols are copied, but property descriptors are not considered\n     *\n     * @param object the object to clone\n     * @param realm the realm the object resides in\n     * @param handleCopy the function that handles copying the object\n     * @returns the copied object\n     */\n    var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\n        var clone = getCleanClone(object, realm);\n        // set in the cache immediately to be able to reuse the object recursively\n        cache.set(object, clone);\n        for (var key in object) {\n            if (hasOwnProperty.call(object, key)) {\n                clone[key] = handleCopy(object[key], cache);\n            }\n        }\n        if (SYMBOL_PROPERTIES) {\n            var symbols = getOwnPropertySymbols(object);\n            for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {\n                symbol = symbols[index];\n                if (propertyIsEnumerable.call(object, symbol)) {\n                    clone[symbol] = handleCopy(object[symbol], cache);\n                }\n            }\n        }\n        return clone;\n    };\n    /**\n     * @function getObjectCloneStrict\n     *\n     * @description\n     * get a copy of the object based on strict rules, meaning all keys and symbols\n     * are copied based on the original property descriptors\n     *\n     * @param object the object to clone\n     * @param realm the realm the object resides in\n     * @param handleCopy the function that handles copying the object\n     * @returns the copied object\n     */\n    var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\n        var clone = getCleanClone(object, realm);\n        // set in the cache immediately to be able to reuse the object recursively\n        cache.set(object, clone);\n        var properties = SYMBOL_PROPERTIES\n            ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object))\n            : getOwnPropertyNames(object);\n        for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {\n            property = properties[index];\n            if (property !== 'callee' && property !== 'caller') {\n                descriptor = getOwnPropertyDescriptor(object, property);\n                if (descriptor) {\n                    // Only clone the value if actually a value, not a getter / setter.\n                    if (!descriptor.get && !descriptor.set) {\n                        descriptor.value = handleCopy(object[property], cache);\n                    }\n                    try {\n                        defineProperty(clone, property, descriptor);\n                    }\n                    catch (error) {\n                        // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n                        clone[property] = descriptor.value;\n                    }\n                }\n                else {\n                    // In extra edge cases where the property descriptor cannot be retrived, fall back to\n                    // the loose assignment.\n                    clone[property] = handleCopy(object[property], cache);\n                }\n            }\n        }\n        return clone;\n    };\n    /**\n     * @function getRegExpFlags\n     *\n     * @description\n     * get the flags to apply to the copied regexp\n     *\n     * @param regExp the regexp to get the flags of\n     * @returns the flags for the regexp\n     */\n    var getRegExpFlags = function (regExp) {\n        var flags = '';\n        if (regExp.global) {\n            flags += 'g';\n        }\n        if (regExp.ignoreCase) {\n            flags += 'i';\n        }\n        if (regExp.multiline) {\n            flags += 'm';\n        }\n        if (regExp.unicode) {\n            flags += 'u';\n        }\n        if (regExp.sticky) {\n            flags += 'y';\n        }\n        return flags;\n    };\n\n    // utils\n    var isArray = Array.isArray;\n    var getPrototypeOf = Object.getPrototypeOf;\n    var GLOBAL_THIS = (function () {\n        if (typeof globalThis !== 'undefined') {\n            return globalThis;\n        }\n        if (typeof self !== 'undefined') {\n            return self;\n        }\n        if (typeof window !== 'undefined') {\n            return window;\n        }\n        if (typeof global !== 'undefined') {\n            return global;\n        }\n        if (console && console.error) {\n            console.error('Unable to locate global object, returning \"this\".');\n        }\n        return this;\n    })();\n    /**\n     * @function copy\n     *\n     * @description\n     * copy an value deeply as much as possible\n     *\n     * If `strict` is applied, then all properties (including non-enumerable ones)\n     * are copied with their original property descriptors on both objects and arrays.\n     *\n     * The value is compared to the global constructors in the `realm` provided,\n     * and the native constructor is always used to ensure that extensions of native\n     * objects (allows in ES2015+) are maintained.\n     *\n     * @param value the value to copy\n     * @param [options] the options for copying with\n     * @param [options.isStrict] should the copy be strict\n     * @param [options.realm] the realm (this) value the value is copied from\n     * @returns the copied value\n     */\n    function copy(value, options) {\n        // manually coalesced instead of default parameters for performance\n        var isStrict = !!(options && options.isStrict);\n        var realm = (options && options.realm) || GLOBAL_THIS;\n        var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n        /**\n         * @function handleCopy\n         *\n         * @description\n         * copy the value recursively based on its type\n         *\n         * @param value the value to copy\n         * @returns the copied value\n         */\n        var handleCopy = function (value, cache) {\n            if (!value || typeof value !== 'object') {\n                return value;\n            }\n            if (cache.has(value)) {\n                return cache.get(value);\n            }\n            var prototype = value.__proto__ || getPrototypeOf(value);\n            var Constructor = prototype && prototype.constructor;\n            // plain objects\n            if (!Constructor || Constructor === realm.Object) {\n                return getObjectClone(value, realm, handleCopy, cache);\n            }\n            var clone;\n            // arrays\n            if (isArray(value)) {\n                // if strict, include non-standard properties\n                if (isStrict) {\n                    return getObjectCloneStrict(value, realm, handleCopy, cache);\n                }\n                clone = new Constructor();\n                cache.set(value, clone);\n                for (var index = 0, length_1 = value.length; index < length_1; ++index) {\n                    clone[index] = handleCopy(value[index], cache);\n                }\n                return clone;\n            }\n            // dates\n            if (value instanceof realm.Date) {\n                return new Constructor(value.getTime());\n            }\n            // regexps\n            if (value instanceof realm.RegExp) {\n                clone = new Constructor(value.source, value.flags || getRegExpFlags(value));\n                clone.lastIndex = value.lastIndex;\n                return clone;\n            }\n            // maps\n            if (realm.Map && value instanceof realm.Map) {\n                clone = new Constructor();\n                cache.set(value, clone);\n                value.forEach(function (value, key) {\n                    clone.set(key, handleCopy(value, cache));\n                });\n                return clone;\n            }\n            // sets\n            if (realm.Set && value instanceof realm.Set) {\n                clone = new Constructor();\n                cache.set(value, clone);\n                value.forEach(function (value) {\n                    clone.add(handleCopy(value, cache));\n                });\n                return clone;\n            }\n            // blobs\n            if (realm.Blob && value instanceof realm.Blob) {\n                return value.slice(0, value.size, value.type);\n            }\n            // buffers (node-only)\n            if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n                clone = realm.Buffer.allocUnsafe\n                    ? realm.Buffer.allocUnsafe(value.length)\n                    : new Constructor(value.length);\n                cache.set(value, clone);\n                value.copy(clone);\n                return clone;\n            }\n            // arraybuffers / dataviews\n            if (realm.ArrayBuffer) {\n                // dataviews\n                if (realm.ArrayBuffer.isView(value)) {\n                    clone = new Constructor(value.buffer.slice(0));\n                    cache.set(value, clone);\n                    return clone;\n                }\n                // arraybuffers\n                if (value instanceof realm.ArrayBuffer) {\n                    clone = value.slice(0);\n                    cache.set(value, clone);\n                    return clone;\n                }\n            }\n            // if the value cannot / should not be cloned, don't\n            if (\n            // promise-like\n            typeof value.then === 'function' ||\n                // errors\n                value instanceof Error ||\n                // weakmaps\n                (realm.WeakMap && value instanceof realm.WeakMap) ||\n                // weaksets\n                (realm.WeakSet && value instanceof realm.WeakSet)) {\n                return value;\n            }\n            // assume anything left is a custom constructor\n            return getObjectClone(value, realm, handleCopy, cache);\n        };\n        return handleCopy(value, createCache());\n    }\n    // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n    // expects there to be a default property on the exported value. See\n    // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n    copy.default = copy;\n    /**\n     * @function strictCopy\n     *\n     * @description\n     * copy the value with `strict` option pre-applied\n     *\n     * @param value the value to copy\n     * @param [options] the options for copying with\n     * @param [options.realm] the realm (this) value the value is copied from\n     * @returns the copied value\n     */\n    copy.strict = function strictCopy(value, options) {\n        return copy(value, {\n            isStrict: true,\n            realm: options ? options.realm : void 0,\n        });\n    };\n\n    return copy;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}